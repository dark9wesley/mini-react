# 树的构建和 Diffing

首先要明确一点，所谓的 Diffing 并不是单独存在的，不是说把树构建完后再进行 Diffing，这么做效率太差了。

而是在树构建过程中进行 Diffing，更好的对老节点进行复用。

## 双缓存树

在 React 中最多会同时存在两颗 Fiber 树：

- current Fiber 树：当前屏幕上显示内容对应的 Fiber 树称为 current Fiber 树
- workInProgress：正在构建的树，主要的工作都在这棵树上

当一次更新发起，首先会先从发起更新的 Fiber 向上爬直到 FiberRootNode 根节点。然后根据 current Fiber 树新建一颗 workInProgress 树，然后构建并遍历这颗 workInProgress 树。

如果构建到一半被打断，current 树还在。如果构建并提交完成，直接把 current 树丢掉，让 workInProgress Fiber 树成为新的 current 树。

## 构建过程（第一次挂载）

从这段代码开始，了解 React 第一次挂载时做了什么？当然这一步只会了解主流程

```javascript
const container = ReactDOM.createRoot(document.getElementById('root'))
container.render(<App />)
```

### 创建容器 createContainer

`ReactDOM.createRoot(document.getElementById('root'))` 实际会调用 `react-reconciler/src/fiberReconciler` 中的 `createContainer`

```javascript
function createContainer(container: Container) {
	const hostRootFiber = new FiberNode(HostRoot, {}, null)
	const root = new FiberRootNode(container, hostRootFiber)
	hostRootFiber.updateQueue = createUpdateQueue()
	return root
}
```

首先创建了两个节点：

1. FiberRootNode: 整个应用的根节点，它包含三个数据：
   - container: 应用挂载的容器
   - finishedWork: 构建完成的 workInProgress 树
   - current: 指向当前的 current 树
2. hostRootFiber: Fiber 树的根节点，从它开始往下才是 FiberNode
   - stateNode：指向 FiberRootNode

接着为`hostRootFiber`创建一个`UpdateQueue`，已供更新时使用。

> `UpdateQueue`是一个对接 React 更新使用的数据，暂不深入了解。

这一步的数据结构如下图所示：

![createContainer](../public/assets/createContainer.png)

### 首次更新（挂载） updateContainer

`container.render(<App />)` 实际会调用 `react-reconciler/src/fiberReconciler` 中的 `updateContainer`。

```javascript
function UpdateContainer(
	element: ReactElement | null,
	root: FiberRootNode
) {
	const hostRootFiber = root.current
	const update = createUpdate<ReactElement | null>(element)
	enqueueUpdate(
		hostRootFiber.updateQueue as UpdateQueue<ReactElement | null>,
		update
	)
	scheduleUpdateOnFiber(hostRootFiber)
	return element
}
```

首先会根据传入的`reactElement`（`reactElement`是由 babel 将组件转化得来的），创建一个`Update`，然后将这个`Update`加入到之前给`hostRootFiber`创建的`UpdateQueue`中去。

随后调用`scheduleUpdateOnFiber`开始第一次更新（挂载）。

### scheduleUpdateOnFiber

```javascript
function scheduleUpdateOnFiber(fiber: FiberNode) {
	const root = markUpdateFromFiberToRoot(fiber)
	renderRoot(root)
}

function markUpdateFromFiberToRoot(fiber: FiberNode) {
	let node = fiber
	let parent = node.return
	while (parent !== null) {
		node = parent
		parent = parent.return
	}

	if (node.tag === HostRoot) {
		return node.stateNode
	}

	return null
}
```

`scheduleUpdateOnFiber`所做的事情比较简单，从发起更新的节点开始，一路回到根节点`FiberRootNode`，然后开始`renderRoot`。

### renderRoot

```javascript
function prepareFreshStack(root: FiberRootNode) {
	workInProgress = createWorkInProgress(root.current, {})
}

function renderRoot(root: FiberRootNode) {
	// 根据当前current树创建一颗workInProgress树
	prepareFreshStack(root)

	do {
		try {
			workLoop()
			break
		} catch (e) {
			// 错误处理
		}
	} while (true)

	// workInProgress树构建完成后进入Commit流程
	// 暂时忽略
	const finishedWork = root.current.alternate
	root.finishedWork = finishedWork

	commitRoot(root)
}
```

首先会根据当前 current 树创建一颗 workInProgress 树，并开启一个`do...while...`循环去启动`workLoop`。

注意这里的`do...while...`循环条件是 true，当 workLoop 正确执行完时，会正常 break 结束循环，否则会做错误处理，然后接着循环。

### workLoop

```javascript
function workLoop() {
	while (workInProgress !== null) {
		performUnitOfWork(workInProgress)
	}
}

function performUnitOfWork(fiber: FiberNode) {
	const next = beginWork(fiber)
	fiber.memorizeProps = fiber.pendingProps

	if (next === null) {
		completeUnitOfFiber(fiber)
	} else {
		workInProgress = next
	}
}

function completeUnitOfFiber(fiber: FiberNode) {
	let node: FiberNode | null = fiber

	do {
		completeWork(node)
		const sibling = node.sibling
		if (sibling !== null) {
			workInProgress = sibling
			return
		}

		node = node.return
		workInProgress = node
	} while (node !== null)
}
```

workLoop 是一个深度优先遍历的过程，可以分为两个阶段：

1. 向下 **递** 的 beginWork
1. 向上或向右 **归** 的 completeWork

#### beginWork

```javascript
const beginWork = (wip: FiberNode) => {
	switch (wip.tag) {
		case HostRoot:
			return updateHostRoot(wip)
		case HostComponent:
			return updateHostComponent(wip)
		case HostText:
			return null
		case FunctionComponent:
			return updateFunctionComponent(wip)
	}
}
```

`beginWork`会根据`fiber tag`进行逻辑分发，但主要的目的都是同一个：

根据当前`fiber.alternate.child`，也就是对比`current`树中的`子fiber`与当前的`子reactElement`，生成`子fiber node`。
